use miden::protocol::active_note
use miden::protocol::note
use miden::protocol::output_note
use miden::core::sys
use miden::standards::wallets::basic->wallet

# Memory Addresses
const ASSET=0
const ASSET_HALF=4
const ACCOUNT_ID_PREFIX=8
const TAG=10

# => []
begin
    # Drop word if user accidentally pushes note_args
    dropw
    # => []

    # Get asset contained in note
    push.ASSET exec.active_note::get_assets drop drop
    # => []

    mem_loadw_be.ASSET
    # => [ASSET]

    # Compute half amount of asset
    swap.3 push.2 div swap.3
    # => [ASSET_HALF]

    mem_storew_be.ASSET_HALF dropw
    # => []

    mem_loadw_be.ASSET
    # => [ASSET]

    # Receive the entire asset amount to the wallet
    call.wallet::receive_asset
    # => []

    # Push script hash
    exec.active_note::get_script_root
    # => [SCRIPT_HASH]

    # Get the current note serial number
    exec.active_note::get_serial_number
    # => [SERIAL_NUM, SCRIPT_HASH]

    # Increment serial number by 1
    push.1 add
    # => [SERIAL_NUM+1, SCRIPT_HASH]

    # Load note inputs into memory for recipient and tag
    push.ACCOUNT_ID_PREFIX
    exec.active_note::get_inputs
    # => [num_inputs, dest_ptr, SERIAL_NUM+1, SCRIPT_HASH]

    swap
    # => [dest_ptr, num_inputs, SERIAL_NUM+1, SCRIPT_HASH]

    exec.note::build_recipient
    # => [RECIPIENT]

    # Push note type to stack (public note)
    push.1
    # => [note_type, RECIPIENT]

    # Load tag from memory
    mem_load.TAG
    # => [tag, note_type, RECIPIENT]

    call.output_note::create
    # => [note_idx, pad(15) ...]

    padw mem_loadw_be.ASSET_HALF
    # => [ASSET / 2, note_idx]

    call.wallet::move_asset_to_note
    # => [ASSET, note_idx, pad(11)]

    dropw drop
    # => []

    exec.sys::truncate_stack
    # => []
end
